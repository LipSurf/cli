#!/usr/bin/env node
'use strict';
const program = require('commander');
const rollup = require('rollup');
const getConfig = require('./rollup.config');
const globby = require('globby');
const ts = require('typescript');
const fs = require('fs');
const jscodeshift = require('jscodeshift');
const execSync = require('child_process').execSync;
const ParsedPlugin = require('./lib/ParsedPlugin').default;

const FOLDER_REGX = /^src\/(.*)\/([^.]*).*$/;

program
  .option('-p, --project', 'ts config file path', './tsconfig.json')
  .option('-o, --out-dir <destination>', 'destination', 'dist');

program
  .command('build [...PLUGINS]')
  .description('build lipsurf plugins')
  .option('-w, --watch')
  .action(async (plugins, cmdObj) => {
    await build({...cmdObj, ...cmdObj.parent}, plugins);
  });

program
  .command('vup')
  .description('up the minor version of all the plugins')
  .option('-v, --version <version>', 'specify a version instead of incrementing the minor version by 1')
  .action(async (cmdObj) => {
    await upVersion({...cmdObj, ...cmdObj.parent});
  });

program.parse(process.argv);

const parseConfigHost /* : any */ = {
  fileExists: ts.sys.fileExists,
  readDirectory: ts.sys.readDirectory,
  readFile: ts.sys.readFile,
  useCaseSensitiveFileNames: true,
};
const configFileName = ts.findConfigFile(
  "./",
  ts.sys.fileExists,
  "tsconfig.json"
);

function compile(config) {
  let program = ts.createProgram(config.fileNames, config.options);
  let emitResult = program.emit();

  let allDiagnostics = ts
    .getPreEmitDiagnostics(program)
    .concat(emitResult.diagnostics);

  allDiagnostics.forEach(diagnostic => {
    if (diagnostic.file) {
      let { line, character } = diagnostic.file.getLineAndCharacterOfPosition(
        diagnostic.start
      );
      let message = ts.flattenDiagnosticMessageText(
        diagnostic.messageText,
        "\n"
      );
      console.log(
        `${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`
      );
    } else {
      console.log(
        `${ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n")}`
      );
    }
  });

  if (emitResult.emitSkipped)
    throw 'TypeScript compile errors.'
}

const formatHost = {
  getCanonicalFileName: path => path,
  getCurrentDirectory: ts.sys.getCurrentDirectory,
  getNewLine: () => ts.sys.newLine
};

function watchTs() {
  // TypeScript can use several different program creation "strategies":
  //  * ts.createEmitAndSemanticDiagnosticsBuilderProgram,
  //  * ts.createSemanticDiagnosticsBuilderProgram
  //  * ts.createAbstractBuilder
  // The first two produce "builder programs". These use an incremental strategy
  // to only re-check and emit files whose contents may have changed, or whose
  // dependencies may have changes which may impact change the result of prior
  // type-check and emit.
  // The last uses an ordinary program which does a full type check after every
  // change.
  // Between `createEmitAndSemanticDiagnosticsBuilderProgram` and
  // `createSemanticDiagnosticsBuilderProgram`, the only difference is emit.
  // For pure type-checking scenarios, or when another tool/process handles emit,
  // using `createSemanticDiagnosticsBuilderProgram` may be more desirable.
  const createProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram;

  // Note that there is another overload for `createWatchCompilerHost` that takes
  // a set of root files.
  const host = ts.createWatchCompilerHost(
    configFileName,
    {},
    ts.sys,
    createProgram,
    reportDiagnostic,
    reportWatchStatusChanged
  );

  // You can technically override any given hook on the host, though you probably
  // don't need to.
  // Note that we're assuming `origCreateProgram` and `origPostProgramCreate`
  // doesn't use `this` at all.
  const origCreateProgram = host.createProgram;
  host.createProgram = (
    rootNames,
    options,
    host,
    oldProgram
  ) => {
    console.log("Compiling changed typescript...");
    return origCreateProgram(rootNames, options, host, oldProgram);
  };
  const origPostProgramCreate = host.afterProgramCreate;

  host.afterProgramCreate = program => {
    console.log("Done compiling changed typescript.");
    origPostProgramCreate(program);
  };

  // `createWatchProgram` creates an initial program, watches files, and updates
  // the program over time.
  ts.createWatchProgram(host);
}

function reportDiagnostic(diagnostic) {
  console.error(
    "Error",
    diagnostic.code,
    ":",
    ts.flattenDiagnosticMessageText(
      diagnostic.messageText,
      formatHost.getNewLine()
    )
  );
}

/**
 * Prints a diagnostic every time the watch status changes.
 * This is mainly for messages like "Starting compilation" or "Compilation completed".
 */
function reportWatchStatusChanged(diagnostic) {
  console.info(ts.formatDiagnostic(diagnostic, formatHost));
}

async function build(options, plugins) {
    if (typeof plugins === 'undefined')
      plugins = [];
    let pluginNames = [].concat(plugins);
    const watch = options.watch;
    const timeStart = new Date();
    const globbedTs = globby.sync(['src/*/*.ts', '!src/*/*.*.ts', '!src/@types']);
    if (!pluginNames.length) {
      pluginNames = Array.from(new Set(globbedTs
         .map(filePath => FOLDER_REGX.exec(filePath))
         .filter(regxRes => regxRes && regxRes[1] === regxRes[2])
         .map(regxRes => regxRes[1])));
    }
    const rollupConfig = await getConfig(options.outDir, pluginNames, process.cwd() + '/', options.prod);
    // initial run of watch for ts doesn't output anything so we compile this way
    const configFile = ts.readConfigFile(configFileName, ts.sys.readFile);
    const parsedConfig = ts.parseJsonConfigFileContent(configFile.config, parseConfigHost, './');
    compile(parsedConfig);
    if (watch) {
      watchTs();
      const watcher = rollup.watch(rollupConfig);
      watcher.on('event', event => {
        switch (event.code) {
          case 'END':
            console.log('Done building. Watching...');
            break;
          case 'ERROR':
          case 'FATAL':
            console.log(event.code, event.error);
            break;
        }
      });
    } else {
      const tsTimeEnd = new Date();
      console.log(`Done with ts compile after ${Math.round((tsTimeEnd - timeStart)/1000)} seconds.`)
      for (let conf of rollupConfig) {
        const bundle = await rollup.rollup(conf)
        await bundle.generate(conf);
        await bundle.write(conf);
      }
      const timeEnd = new Date();
      console.log(`Done building in ${Math.round((timeEnd - timeStart)/1000)} seconds.`);
    }
}

async function upVersion(options) {
  // make sure there are no other changes so that we don't include them in the upversion commit
  try {
    execSync('git diff-index --ignore-submodules --quiet HEAD --').toString();
  } catch (e) {
    console.error(`There are uncommitted things. Commit them before running vup.`)
    return;
  }
  // first find a plugin file
  const parDir = `${options.outDir}/tmp`
  let files;
  try {
    files = fs.readdirSync(parDir);
  } catch (e) {
    console.error(`Expected temporary build plugin files in ${parDir}. Try running \`yarn build\` first. We need these to read the .mjs plugins (can't read ts directly for now) and extract a current version.`);
    return;
  }
  const allPluginNames = files.filter(x => !x.startsWith('.') || x.endsWith('.mjs'), {});
  const anyPluginName = allPluginNames[0];
  const source = fs.readFileSync(`${parDir}/${anyPluginName}.joined.mjs`).toString();
  const parsed = new ParsedPlugin(jscodeshift, source);
  const oldVersion = parsed.getVersion()

  console.log(`latest version of ${anyPluginName}: ${oldVersion}`);
  const versionSplit = oldVersion.split('.');
  const newVersion = options.version || `${versionSplit[0]}.${(+versionSplit[1]) + 1}.0`;
  console.log(`upping to: ${newVersion}`)
  execSync(`sed -i "s/version: '${oldVersion}'/version: '${newVersion}'/g" src/*/*.ts`);
  await build({outDir: options.outDir, prod: true});
  // remove the old plugins
  try {
    execSync(`rm dist/*.${oldVersion.replace(/\./g, '-')}.*.ls`);
  } catch (e) {
    console.warn("error removing old version's files");
  }
  // make an vup commit (version tagging is done by the parent repo -- which determines which commit actually gets into the extension's package)
  execSync('git add dist');
  execSync(`git commit -m "Version upped from ${oldVersion} to ${newVersion}" -a`);
}